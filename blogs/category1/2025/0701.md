---
title: 手撕面包
date: 2025-10-07
tags:
  - interview
categories:
  - 总结
---
## 九、文字溢出

:::info 文字溢出与文本溢出

- **文字溢出** 重点是单个字符的视觉表现和排版

先展示单行方案，强调这是最基础最重要的；
再展示多行方案，说明WebKit限制和替代方案；
重点体现对CSS基础属性的熟练掌握；

- **文本溢出** 重点是段落内容的布局和结构处理

重点展示兼容性更好的定位方案；
详细说明伪元素的实现原理；
讨论背景色匹配、行高计算等细节问题；
体现解决实际问题的能力；
:::

### 单行文字实现

```css
.text{
  text-overflow: ellipsis;
  overflow: hidden ;
  white-space: nowrap;
}
```

### 多行文字实现

```css
.p{
  overflow : hidden;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  display: -webkit-box;
}
```

## 八、文本溢出

前端开发中使用场景：内容列表展示、卡片布局。有两种方式，如果对兼容性要求高，需要支持所有现代浏览器，使用`定位伪元素遮盖`；若用户使用的是Chrome或Safari，使用`旧版弹盒法`。

### 定位伪元素遮盖

```css
.father{/*父元素*/
  postion:relative;/*子绝父相 给伪元素定位*/
  overflow:hidden;
  text-align:justify;
  line-height:20px;
}
.father::after{
  position:absolute;
  right:0;
  bottom:0;
  content:'...';/*插入省略文本*/
  width:1em;/*为了遮盖时正好遮住原来一个字的大小*/
  background-color:''；/*设置和父元素背景相同的颜色*/
}
```
::: info 伪元素vs伪类
伪元素：创建不在文档树中的虚拟元素，`::`

伪类：选择已有元素的状态，`:`
:::

### 旧版弹性盒法

```css
.box{
  display: -webkit-box;
  /* 弹性盒子元素垂直排列 */
  -webkit-box-orient: vertical;
  /* 控制要显示的行数 */
  -webkit-line-clamp: 3;
  overflow: hidden;
}
```

## 七、三栏布局

### 解释

将页面水平分为三份，表现形式：左右固定中间自适应（常见，`经典圣杯布局、双飞翼布局`）、左右自适应中间固定、三个都自适应（比例一般1：2：1）、一个固定两个自适应（少见）

### 实现方式

**绝对定位不推荐，脱离文档流**

> `‌relative`‌：不脱离文档流，不影响其他元素布局。`absolute‌`：脱离文档流，根据父元素或根元素定位。 ‌

:::: code-group
::: code-group-item 圣杯（浮动）
```html
<div class="container">
  <div class="main">中间自适应</div>
  <div class="left">左侧固定</div>
  <div class="right">右侧固定</div>
</div>
<style>
 .contain{
    padding: 0 200px;
    overflow: hidden;
  }
  .main,.left,.right{
    float: left;
    position: relative;
    min-height: 300px;
  }
  .main{
    background-color: pink;
    width: 100%;
  }
  .left{
    background-color: plum;
    margin-left: -100%;/* 移动到上一行的最左侧 */
    right: 200px;/* 相对定位调整到正确位置 */
    width: 200px;
  }
  .right{
    background-color: aquamarine;
    width: 200px;
    /* 为什么不用margin-right?
    因为所有栏都设置了float:left 元素从左到右排列 一定要用margin-left 移动到上一行的最右侧*/
    margin-left: -200px;
    left: 200px;/* 相对定位调整到正确位置 */
  }
</style>
```
:::

::: code-group-item 双飞翼（浮动）

```html
<div class="double-wing">
  <div class="main-wrapper">
    <div class="main">中间内容（自适应）</div>
  </div>
  <div class="left">左侧边栏（固定200px）</div>
  <div class="right">右侧边栏（固定200px）</div>
</div>
<style>
.double-wing {
  overflow: hidden;
  min-height: 300px;
}
.main-wrapper, .left, .right {
  float: left;
  min-height: 300px;
}
.main-wrapper {
  width: 100%;
  background: pink;
}
.main {
  margin: 0 200px;/* 主要内容区域的内边距 */
  height: 100%;
  background: plum;
}
.left {
  width: 200px;
  margin-left: -100%;/* 移动到第一行最左边 */
  background: beige;
}
.right {
  width: 200px;
  margin-left: -200px;/* 移动到第一行最右边 */
  background: beige;
}
</style>
```
:::

::: code-group-item flexBox（推荐）

```html
<div class="flex-container">
  <div class="left">左侧边栏（固定200px）</div>
  <div class="main">中间内容（自适应）</div>
  <div class="right">右侧边栏（固定200px）</div>
</div>
<style>
.flex-container{
  display: flex;
  min-height: 300px;
}
.left{
  width: 200px;
  order: 1;/*控制显示顺序*/
  background: plum;
}
.main{
  flex: 1;/*占据剩余所有空间*/
  order: 2;
  background: pink;
}
.right{
  width: 200px;
  order: 3;
  background: plum;
}
</style>
```
:::

::: code-group-item grid(简洁实现)

```html
<div class="grid-container">
  <div class="left">左侧边栏（固定200px）</div>
  <div class="main">中间内容（自适应）</div>
  <div class="right">右侧边栏（固定200px）</div>
</div>
<style>
.grid-container{
  display: grid;
  grid-template-columns: 200px 1fr 200px; /* 左右固定，中间自适应 */
  min-height: 300px;
  gap: 0; /* 可选：去掉间距 */
}
.left{
  background: plum;
}
.main{
  background: pink;
}
.right{
  background: plum;
}
</style>
```
:::
::::

:::info 圣杯和双飞翼的名字由来
- 圣杯：西方文化中象征着"神圣的追求目标"（耶稣晚餐用过的杯子 比作美好），这个布局在当时（2006年左右）被认为是CSS布局的"圣杯"——一个难以实现但非常理想的三栏布局目标。
- 双飞翼：由淘宝UED团队提出，名字来源于"双翼"，比喻中间内容区域像鸟的身体，左右两侧像翅膀一样展开。
- 两者都是三栏布局，且最后呈现的视觉效果相同，但代码实现思路不同；
- 双飞翼是圣杯的优化版本，解决了浏览器兼容问题；圣杯的html结构更简洁，双飞翼多一层包裹。
- **注意**：圣杯布局和双飞翼布局的中间栏div都是在html结构中先写的，这样写浏览器会优先解析展示中间内容，**利于SEO**.
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-10-03_20-35-29.jpg)
:::

## 六、两栏布局

### 解释

两栏布局是一种布局现象，并不是css种规定的专业名词，但行业通用。

最常见的是左侧固定、右侧自适应；除此之外，还有右侧固定、左侧自适应；两侧都自适应
```html
<div class="container">
  <div class="left">左边浮动元素</div>
  <div class="right">右边普通元素</div>
</div>
```

### 实现方式

掌握浮动和Flex就足够应对大多数情况。

Grid布局比较新颖（语义化）；绝对定位：不推荐，影响文档流；表格布局：display: table 已过时

:::: code-group
::: code-group-item 浮动
```css
/* 1.父元素加BFC，固定部分浮动并给出宽高，自适应部分使用margin-方向来固定 */
.container {
  border: 3px solid red; /* 用红色边框标识父容器范围 */
  overflow: hidden;
}

.left {
  float: left;
  width: 200px;
  background-color: gray;
  height: 400px;
}

.right {
  /* 注意：这里没有 margin-left */
  margin-left: 200px;
  background-color: lightgray;
  height: 200px;
}
```
:::

::: code-group-item flexBox

```css
/* 2.父元素flex，固定部分给出宽度，自适应部分用flex:1的属性拉满剩余空间 */
.container {
  border: 3px solid red; /* 用红色边框标识父容器范围 */
  display: flex;
}
.left {
  width: 200px;
  background-color: gray;
  height: 400px;
}
.right {
  flex: 1;/* 自适应部分占据剩余空间 */
  background-color: lightgray;
  height: 200px;
}
```
:::

::: code-group-item Grid

```css
/* 3.Grid布局 新颖且语义化; */
.container {
  border: 3px solid red; /* 用红色边框标识父容器范围 */
  display: grid;
  grid-template-columns: 250px 1fr;/*第一列宽度250px 第二列宽度剩余空间的一部分*/
  grid-template-areas: "sidebar main";/*定义子元素语义化属性*/
}
.left {
  grid-area: sidebar;
  background: #f0f0f0;
  background-color: gray;
  height: 400px;
}

.right {
  grid-area: main;
  background-color: lightgray;
  height: 200px;
}
```
:::
:::: code-group

## 五、查找

**Q:数组[1,2,2,3,4]，找出值为2的元素**
```js
const arr = [1,2,2,3,4]
const res = arr.find(item=>item===2)//返回第一个符合条件的值 2
const res2 = arr.filter(item=>item===2)//返回所有符合条件的值，组成新数组 [2,2]

const index = arr.indexOf(2)//返回第一个符合条件的索引, -1表示没有找到
if(index!==-1){ console.log( arr[index] ); }
console.log(arr.findIndex(item=>item===2));//返回第一个符合条件的索引, -1表示没有找到
// indexOf 和 findIndex 的区别是，indexOf只能查找基本类型的值，findIndex可以查找复杂类型的值

console.log(arr.includes(2));//返回布尔值，表示是否包含某个值
```

## 四、for in & for of

### 两者区别

- in 👉🏻 index 索引 👉🏻  索引用于获取位置和键名 👉🏻 键名：对象（遍历对象的可枚举属性，包括自身属性和继承的属性）👉🏻 hasOwnProperty
- of 👉🏻  valueOf 值 👉🏻  数组
:::info 我的疑问
为什么不建议用 for...in 遍历数组?
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-26_14-58-11.jpg)

:::

### for in的陷阱和规避

**陷阱：** 遍历对象自身的可枚举属性以及继承的可枚举属性。意味着对象的原型链上有可枚举属性，这些属性也会被遍历到。但在开发时通常只需要关注自身属性。

**规避：** 两种方法。

- `arr.hasOwnProperty`如果对象自身有 hasOwnProperty 方法，那么直接调用是没问题的。但是，如果对象没有自己的 hasOwnProperty 方法（比如，对象是通过 Object.create(null) 创建的），或者对象的 hasOwnProperty 方法被覆盖了，那么就会出错
- `Object.prototype.hasOwnProperty.call(arr, index)`更安全，因为它直接使用 Object.prototype 上的 hasOwnProperty 方法，避免了对象自身可能没有 hasOwnProperty 方法或者该方法被覆盖的情况。
```js
Array.prototype.customMethod = function() {};

const arr = ['a', 'b', 'c'];

// 使用for...in循环
for (let index in arr) {
    console.log(index);  // 输出: 0, 1, 2,customMethod
}
for (let index in arr) {
    if (arr.hasOwnProperty(index)) {
        console.log(index); // 只输出: 0, 1, 2
    }
}
```

## 三、防抖节流

### 防抖 debounce

>bounce有抖动的意思，防止抖动，防抖是前端开发中的性能优化技巧。可以把它想象成`电梯的开门机制`。电梯门打开后，如果没有人进出，它会在等待一段时间后自动关闭。但如果在这段等待时间内`有人进出（再次触发事件）`，电梯会重新开始计时等待，直到真正没有人进出了，它才会关闭。

**核心思想：** 在事件被触发的n秒后再执行，若n秒内再次触发，则重新计时。`巧妙利用闭包`

**应用场景：** 搜索框输入联想、窗口大小调整、按钮防重复提交、文本编辑器实时保存（在在线文档如Notion、语雀中编辑内容，希望内容能实时保存）       

**方法：**
- Lodash `_.debounce` 函数
- 手写
```js
// 没有立即执行功能的防抖
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    // const context = this 
    //如果我们在下面的setTimeout使用箭头函数，可以省略context；如果使用普通函数，则需要保存context。
    //使用箭头函数作为setTimeout的回调，箭头函数不会改变this的指向，所以它会使用外部函数的this。而外部函数的this是在调用时确定的，也就是debounce返回的函数被调用时的this。
    clearTimeout(timer)

    timer = setTimeout(() => {
      timer = null
      fn.apply(this, args)
    }, delay)
  }
}

// 有立即执行功能的防抖
function correctDebounce(func, wait, immediate = false) {
  let timeoutId = null;
  
  return function(...args) {
    // 注意：这里省略了const context = this;所有的setTimeout用箭头函数才可以省略
    if (timeoutId) clearTimeout(timeoutId);
    
    if (immediate) {
      // 如果没有 callNow 检查，每次调用都会立即执行函数，这完全失去了防抖的意义。
      const callNow = !timeoutId; //检查当前是否已经有定时器在运行

       //创建冷却期并在结束后重置状态，为下一次立即执行做准备
      setTimeout(() => {
        timeoutId = null;
      }, wait);
      
      // 在立即执行模式下，当没有活跃定时器，立即执行函数
      if (callNow) {
        func.apply(this, args);
      }//为什么没有else了，因为!callNow就是 if (timeoutId)第一步的实现
    } else {
      // 标准防抖模式：等待一段时间后执行函数
      timeoutId = setTimeout(() => {
        func.apply(this, args);
      }, wait);
    }
  };
}
```

::: info 从手写函数拓展出的问题
1. **关于手写函数的知识点**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_00-40-41.jpg)
1. **防抖中的妙用：闭包实现防抖的状态管理**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-53-20.jpg)
1. **JavaScript 中的计时函数，如`setTimeout, setInterval`以及许多其他 Web API如`requestAnimationFrame`确实普遍使用`毫秒`作为时间单位,为什么？**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-27-34.jpg)
1. **`16.7ms` 是前端工程师在追求高性能和流畅体验时，一个必须时刻铭记的预算上限。**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-39-25.jpg)如果你的 JavaScript 代码（比如一个 mousemove 事件处理函数，或者一个动画循环）执行时间过长，超过了这 16.7ms，就会挤占后续步骤的时间。导致浏览器无法在下一帧开始前完成所有工作，最终结果就是掉帧（Dropped Frames），动画看起来就会卡顿。
:::

### 节流 throttle

**重点：**<br>
- 防抖是将多次执行变为最后一次执行
- 节流是将多次执行变为每隔一段时间执行

**应用场景：** 滚动事件监听scroll、窗口调整 resize、鼠标移动 mousemove、游戏中的按键操作、无限滚动加载更多内容

**实现方式：**<br>
- 定时器方式：使用setTimeout，第一次延迟执行，之后按固定频率执行`需要确保最后一次操作被执行`（尾部执行节流函数）
- 时间戳方式：使用时间戳比较，第一次立即执行，之后按固定频率执行`针对需要立即响应的用户操作`
- 结合方式：结合了时间戳和定时器，既保证立即执行又保证最终执行`结合：最好的用户体验`

```js
// 1.尾部执行节流函数
function throtle(fn,interval){
  let timer = null
  // 处理时间间隔参数，确保安全性和合理性
  // 16.67毫秒，对应60帧每秒的动画频率
  const wait = Math.max(Number(interval)||1000/60 , 0)

  return function(...args){
    // 如果有定时器正在运行，说明还在冷却期，直接返回不执行
    // 这是节流的核心：固定时间间隔内只执行一次
    if(timer) return 

    timer = setTimeout(()=>{
      // 定时器执行后，清空timer标识，允许下一次调用
      // 必须在执行fn前或后清空，否则会一直处于冷却状态
      time = null
      fn.appy(this,args)
    },wait)
  }
}
```

## 二、深浅拷贝

### 前置知识点回顾

- 数据类型分为基本数据类型（String、Number、Boolean、Null、undefined、Symbol）和引用数据类型;
- 基本数据类型储存在栈(stack)中，引用数据类型的引用(pointer)储存在栈中，真实数据存在在堆(heap)里;

> 针对以上困惑的点：指针这个东西不是链表里才有吗？为什么引用数据类型也有指针呢？解答：指针（Pointer）是一个通用计算机科学概念，链表使用了指针，但指针的应用远不止于链表。几乎所有需要处理动态内存或引用语义的编程语言和场景中，指针（或类似指针的引用）都是最核心的机制。

> 衍生问题：1.你刚刚说的栈用于储存固定大小的数据如基本类型我能够理解，但还储存函数调用上下文是什么意思？这个上文和指针有关系吗？2.你说的栈有大小限制，递归过深会出现栈溢出，这个溢出会带来什么后果？如何防止？3.你说C++可以直接操作指针，为什么C++语言需要而JS不需要呢 [link](https://chat.deepseek.com/a/chat/s/75414d18-65a8-4434-a7a1-edbfed0589e6)

- 深浅拷贝的**区别**：**若一个对象中包含引用类型，浅拷贝会共享引用地址，改变嵌套对象的值会改变相应的嵌套对象；深拷贝则不会**。当然，浅拷贝若修改的是顶层的基本属性，那么原对象不会收到影响。
- 所以，选择深浅拷贝不是“非黑即白”，而是基于需求的决策。**我是否需要完全切断新对象和原对象在所有层级上的联系**？
  - 是，使用深拷贝。如创建完全独立的备份、防止函数副作用、保存不可变的历史快照
  - 否，使用浅拷贝。如对象只有一层结构、有意识共享嵌套对象如vuex状态管理

### 浅拷贝

```js
// 1.slice() 
// 2.concat()
// 3.展开运算符(...)
// 4.Object.assign({},obj)
// 4.手写函数实现（重点关注,如下）\
shallowCopy(obj){
  if(typeof obj !== 'obj'|| obj === null) return obj
  const copy = Array.isArray(obj) ? [] : {} //为什么用const  const关键字的真正含义：保证引用不变，而非值不变
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      copy[key] = obj[key]
    }
  }
  return copy
}
```
> 疑惑的点：Object.assign()的第一个参数非得是对象吗？是的，不能是原始值（如undefined、null、number、string、boolean、symbol、bigint）。如果传入原始值，会被转换为对象（传入string转化成String()）。但是，**在非严格模式下，如果第一个参数是undefined或null，会转换为全局对象（浏览器中是window），这可能导致意外错误**。

> **for...in配合hasOwnProperty是一种常见的写法**，因为 `hasOwnProperty 检查的作用`,避免了原型链上的属性，这是 for...in 的主要问题之一。这样确保我们只复制对象自身的属性。<u>hasOwnProperty() 方法返回一个布尔值，表示对象自有属性（而不是继承来的属性）中是否具有指定的属性。</u>

### 深拷贝

#### 1. JSON.parse(JSON.stringify()) 

>简单易用，一行代码实现；适用于大多数场景 

>无法复制函数、undefined、Symbol等特殊类型；无法处理循环引用；丢失对象的构造函数信息

![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_17-24-27.jpg)

::: info 关于JSON的拓展
从`JSON.parse(JSON.stringify()) `的局限性引发的思考：为什么JSON在转化复杂数据类型时会丢弃，它是基于什么考量？

JSON的设计目标是成为一种平台中立（Platform-Neutral） 和语言无关（Language-Agnostic） 的数据格式。它只包含最基本、最通用、所有现代编程语言都毫无歧义地支持的数据结构（字符串、数字、布尔值、数组、对象/字典、null）。一旦引入了任何语言特有的复杂特性（如JavaScript的函数、Java的类），这种通用性就被破坏了。

JSON是一个独立的、开放的国际标准。JavaScript只是率先并原生支持了它，但现在几乎所有主流编程语言都拥有解析和生成JSON的标准库。

JSON的“挑剔”是一种安全特性和设计哲学的体现，它主动放弃复杂性，选择了简单、安全和通用。

实用性： JSON的核心目的是传递数据（Data），而不是行为（Behavior） 或执行代码（Executable Code）。函数包含的是逻辑和行为，将其序列化并发送给另一个系统是毫无意义的，因为接收方很可能用不同的语言编写，根本不知道如何执行这段JavaScript函数。

安全性：这是最最重要的原因。如果JSON设计成可以序列化函数，那么它会成为一个巨大的安全漏洞。

简单性：保持极简的数据类型集合，确保了所有实现的解析器都是一致和可靠的。如果一个C++程序收到一个JSON，它可以确信里面只包含它也能处理的几种基本类型，而不需要去理解JavaScript特有的复杂概念。
:::

#### 2. Lodash库 _cloneDeep

方便　但会增加项目依赖包

#### 3. 手写深拷贝函数

```js
function deepClone(obj,hash = new WeakMap()){
  // 1.考虑基本数据类型和null可以直接返回
  if(obj===null||typeof !== 'object'){
    return obj
  }
  // 2.如果是Date对象，则返回一个新的Date对象
  if(obj instanceof Date){
    return new Date(obj.getTime())
  }
  // 3. 处理特殊对象：RegExp
  if(obj instanceof RegExp){
    return new RegExp(obj)
  }
  // 4.处理数组
  if(Array.isArray(obj)){
    return obj.map(item => deepClone(item,hash))
  }
  // 5. 处理特殊对象：Map
  if(obj instanceof Map){
    const result = new Map()
    hash.set(obj,result) //等级隐射关系，解决循环引用

    // map.forEach((value, key, mapItself) => {参数顺序：值、键、Map本身});
    obj.forEach((value,key)=>{
      result.set(deepClone(key,hash),deepClone(value,hash))//递归键值对
    })
    return result
  }
  // 6.处理Set函数
  if(obj instanceof Set){
    const result = new Set()
    hash.set(obj,result)

    obj.forEach((value,key)=>{
      result.add(deepClone(value,hash))// 对每个值进行深拷贝，然后添加到新Set中
    })
    return result
  }
  // 7.检查循环引用 - 如果已经拷贝过该对象，直接返回存储的拷贝
  if(hash.has(obj)){
    return hash.get(obj)
  }

  // 8.处理普通对象 - 创建保持原型链的新对象
  // Object.create(null)，把null换成了指定的对象，且这个对象有原型链
  const result = Object.create(Object.getPrototypeOf(obj)) 
  // 建立隐射关系 解决循环引用
  hash.set(obj,result)
  // Reflect.ownKeys获取自由属性 如不可枚举和Symbol属性
  const keys = Reflect.ownKeys(obj)
  for(let key of keys){
    result[key] = deepClone(obj[key], hash)
  }
  return result
}
```
::: info 手写深拷贝函数引发的思考

1. `instanceof`是检查实例归属的方法，且其检查依赖于运行时的原型链。但如果代码运行在多个框架或窗口（iframe）中，由于每个环境都有自己全局的执行上下文和内置构造函数，跨环境的对象检查可能会失败。在这种情况下，使用`Array.isArray()`或`Object.prototype.toString.call()`方法更可靠。
2. `Object.create(null)`是创建一个无原型链的纯净对象，在一些底层框架经常使用
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-10_20-59-54.jpg)
3. 关于手写函数的第二个参数为什么要用`hash = new WeakMap()`
WeakMap 的键是弱引用。这意味着，如果原始对象在其他地方已经没有引用了，它会被垃圾回收机制自动回收，同时它在 WeakMap 中的记录也会被自动清除。这避免了深拷贝这个临时性操作可能导致的内存泄漏。
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_18-36-37.jpg)
WeakMap对应的方法：
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_18-45-55.jpg)
4. `Reflect.ownKeys()` 是 ES6 引入的反射 API 的一部分，返回的是对象**所有自有属性的键**（包括字符串键和Symbol键，无论是否可枚举），这确保了深拷贝能够复制对象的所有属性。
5. 关于Set
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_22-09-59.jpg)
6. 理解`Object.create(Object.getPrototypeOf(obj))`这里不展开写
:::

## 一、数组扁平化

![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-08-27_01-37-30.jpg)

### ES6 的 flat 方法

flat()将以指定的深度递归遍历数组，并将所有元素与遍历的子数组中元素合并到一个新数组中以返回。

**💭flat(Infinity)** 优雅且强大的写法，完全展平一个任意嵌套深度的数组
```js
const arr = [1,[2,[3,[4,5]]],6]
console.log(arr.flat()) //  [1, 2, Array(2), 6]
console.log(arr.flat(Infinity)) // [1,2,3,4,5,6]
```
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-08-27_01-47-44.jpg)

### 使用正则

```js
const arr = [1,[2,[3,[4,5]]],6]
//\[|]\
const res = JSON.stringify(arr).replace(/\[|\]/g,'')
const res2 = JSON.parse('[' + res + ']')
```

### 使用递归

[本博客《算法思想：递归》](/blogs/category1/2025/0601.html#递归思想)

```js
 let array = []  
  const fn = (arr) => {
    for (let i = 0; i < arr.length; i++) {
      if(Array.isArray(arr[i])){
        fn(arr[i])
      }else{
        array.push(arr[i])
      }
    }
  }
  const arr = [1,[2,[3,[4,5]]],6]
  // fn(arr)
  // console.log( array ) //[1,2,3,4,5,6]
```

### 使用reduce

```js
const fn = (arr) => {
  return arr.reduce((pre,cur)=>{
    return pre.concat(Array.isArray(cur)?fn(cur):cur)
  },[])
}
```

### 使用stack思想实现

```js
function flatWithStack(arr) {
  const stack = [...arr].reverse() // 初始栈，逆序压入元素
  const result = []
  while (stack.length > 0) {
    const item = stack.pop()
    if (Array.isArray(item)) {
      stack.push(...item.reverse())// 如果是数组，将其元素逆序压回栈中
    } else {
      result.push(item)// 如果不是数组，加入结果数组
    }
  }
  return result;
}
```