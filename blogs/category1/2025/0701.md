---
title: 手撕面包
date: 2025-09-01
tags:
  - interview
categories:
  - 总结
---
## 三、防抖节流

### 防抖 Debounce

>bounce有抖动的意思，防止抖动，防抖是前端开发中的性能优化技巧。可以把它想象成`电梯的开门机制`。电梯门打开后，如果没有人进出，它会在等待一段时间后自动关闭。但如果在这段等待时间内`有人进出（再次触发事件）`，电梯会重新开始计时等待，直到真正没有人进出了，它才会关闭。

**核心思想：** 在事件被触发的n秒后再执行，若n秒内再次触发，则重新计时。`巧妙利用闭包`

**应用场景：** 搜索框输入联想、窗口大小调整、按钮防重复提交、文本编辑器实时保存（在在线文档如Notion、语雀中编辑内容，希望内容能实时保存）       

**方法：**
- Lodash `_.debounce` 函数
- 手写
```js
// 没有立即执行功能的防抖
function debounce(fn, delay) {
  let timer = null
  return function (...args) {
    // const context = this 
    //如果我们在下面的setTimeout使用箭头函数，可以省略context；如果使用普通函数，则需要保存context。
    //使用箭头函数作为setTimeout的回调，箭头函数不会改变this的指向，所以它会使用外部函数的this。而外部函数的this是在调用时确定的，也就是debounce返回的函数被调用时的this。

    clearTimeout(timer)

    timer = setTimeout(() => {
      timer = null
      fn.apply(this, args)
    }, delay)
  }
}

// 有立即执行功能的防抖
function correctDebounce(func, wait, immediate = false) {
  let timeoutId = null;
  
  return function(...args) {
    // 注意：这里省略了const context = this;所有的setTimeout用箭头函数才可以省略
    if (timeoutId) clearTimeout(timeoutId);
    
    if (immediate) {
      const callNow = !timeoutId; //表示没有定时器（即没有处于延迟时间内），那么callNow为true，应该立即执行。😎

      // 设置一个定时器，在延迟后将时间重置
      timeoutId = setTimeout(() => {
        timeoutId = null;
      }, wait);
      
      // 并不仅仅是第一次调用，而是每次当timeoutId为null（即没有正在等待的定时器）时的调用都会立即执行。😎
      if (callNow) {
        func.apply(this, args);
      }
    } else {//否则等一段时间再调用
      timeoutId = setTimeout(() => {
        func.apply(this, args);
      }, wait);
    }
  };
}
```

::: info 从手写函数拓展出的问题
1. **关于手写函数的知识点**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_00-40-41.jpg)
1. **防抖中的妙用：闭包实现防抖的状态管理**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-53-20.jpg)
1. **JavaScript 中的计时函数，如`setTimeout, setInterval`以及许多其他 Web API如`requestAnimationFrame`确实普遍使用`毫秒`作为时间单位,为什么？**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-27-34.jpg)
1. **`16.7ms` 是前端工程师在追求高性能和流畅体验时，一个必须时刻铭记的预算上限。**
  ![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-19_19-39-25.jpg)如果你的 JavaScript 代码（比如一个 mousemove 事件处理函数，或者一个动画循环）执行时间过长，超过了这 16.7ms，就会挤占后续步骤的时间。导致浏览器无法在下一帧开始前完成所有工作，最终结果就是掉帧（Dropped Frames），动画看起来就会卡顿。
:::


## 二、深浅拷贝

### 前置知识点回顾

- 数据类型分为基本数据类型（String、Number、Boolean、Null、undefined、Symbol）和引用数据类型;
- 基本数据类型储存在栈(stack)中，引用数据类型的引用(pointer)储存在栈中，真实数据存在在堆(heap)里;

> 针对以上困惑的点：指针这个东西不是链表里才有吗？为什么引用数据类型也有指针呢？解答：指针（Pointer）是一个通用计算机科学概念，链表使用了指针，但指针的应用远不止于链表。几乎所有需要处理动态内存或引用语义的编程语言和场景中，指针（或类似指针的引用）都是最核心的机制。

> 衍生问题：1.你刚刚说的栈用于储存固定大小的数据如基本类型我能够理解，但还储存函数调用上下文是什么意思？这个上文和指针有关系吗？2.你说的栈有大小限制，递归过深会出现栈溢出，这个溢出会带来什么后果？如何防止？3.你说C++可以直接操作指针，为什么C++语言需要而JS不需要呢 [link](https://chat.deepseek.com/a/chat/s/75414d18-65a8-4434-a7a1-edbfed0589e6)

- 深浅拷贝的**区别**：**若一个对象中包含引用类型，浅拷贝会共享引用地址，改变嵌套对象的值会改变相应的嵌套对象；深拷贝则不会**。当然，浅拷贝若修改的是顶层的基本属性，那么原对象不会收到影响。
- 所以，选择深浅拷贝不是“非黑即白”，而是基于需求的决策。**我是否需要完全切断新对象和原对象在所有层级上的联系**？
  - 是，使用深拷贝。如创建完全独立的备份、防止函数副作用、保存不可变的历史快照
  - 否，使用浅拷贝。如对象只有一层结构、有意识共享嵌套对象如vuex状态管理

### 浅拷贝

```js
// 1.slice() 
// 2.concat()
// 3.展开运算符(...)
// 4.Object.assign({},obj)
// 4.手写函数实现（重点关注,如下）\
shallowCopy(obj){
  if(typeof obj !== 'obj'|| obj === null) return obj
  const copy = Array.isArray(obj) ? [] : {} //为什么用const  const关键字的真正含义：保证引用不变，而非值不变
  for(let key in obj){
    if(obj.hasOwnProperty(key)){
      copy[key] = obj[key]
    }
  }
  return copy
}
```
> 疑惑的点：Object.assign()的第一个参数非得是对象吗？是的，不能是原始值（如undefined、null、number、string、boolean、symbol、bigint）。如果传入原始值，会被转换为对象（传入string转化成String()）。但是，**在非严格模式下，如果第一个参数是undefined或null，会转换为全局对象（浏览器中是window），这可能导致意外错误**。

> **for...in配合hasOwnProperty是一种常见的写法**，因为 `hasOwnProperty 检查的作用`,避免了原型链上的属性，这是 for...in 的主要问题之一。这样确保我们只复制对象自身的属性。<u>hasOwnProperty() 方法返回一个布尔值，表示对象自有属性（而不是继承来的属性）中是否具有指定的属性。</u>

### 深拷贝

#### 1. JSON.parse(JSON.stringify()) 

>简单易用，一行代码实现；适用于大多数场景 

>无法复制函数、undefined、Symbol等特殊类型；无法处理循环引用；丢失对象的构造函数信息

![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_17-24-27.jpg)

::: info 关于JSON的拓展
从`JSON.parse(JSON.stringify()) `的局限性引发的思考：为什么JSON在转化复杂数据类型时会丢弃，它是基于什么考量？

JSON的设计目标是成为一种平台中立（Platform-Neutral） 和语言无关（Language-Agnostic） 的数据格式。它只包含最基本、最通用、所有现代编程语言都毫无歧义地支持的数据结构（字符串、数字、布尔值、数组、对象/字典、null）。一旦引入了任何语言特有的复杂特性（如JavaScript的函数、Java的类），这种通用性就被破坏了。

JSON是一个独立的、开放的国际标准。JavaScript只是率先并原生支持了它，但现在几乎所有主流编程语言都拥有解析和生成JSON的标准库。

JSON的“挑剔”是一种安全特性和设计哲学的体现，它主动放弃复杂性，选择了简单、安全和通用。

实用性： JSON的核心目的是传递数据（Data），而不是行为（Behavior） 或执行代码（Executable Code）。函数包含的是逻辑和行为，将其序列化并发送给另一个系统是毫无意义的，因为接收方很可能用不同的语言编写，根本不知道如何执行这段JavaScript函数。

安全性：这是最最重要的原因。如果JSON设计成可以序列化函数，那么它会成为一个巨大的安全漏洞。

简单性：保持极简的数据类型集合，确保了所有实现的解析器都是一致和可靠的。如果一个C++程序收到一个JSON，它可以确信里面只包含它也能处理的几种基本类型，而不需要去理解JavaScript特有的复杂概念。
:::

#### 2. Lodash库 _cloneDeep

方便　但会增加项目依赖包

#### 3. 手写深拷贝函数

```js
function deepClone(obj,hash = new WeakMap()){
  // 1.考虑基本数据类型和null可以直接返回
  if(obj===null||typeof !== 'object'){
    return obj
  }
  // 2.如果是Date对象，则返回一个新的Date对象
  if(obj instanceof Date){
    return new Date(obj.getTime())
  }
  // 3. 处理特殊对象：RegExp
  if(obj instanceof RegExp){
    return new RegExp(obj)
  }
  // 4.处理数组
  if(Array.isArray(obj)){
    return obj.map(item => deepClone(item,hash))
  }
  // 5. 处理特殊对象：Map
  if(obj instanceof Map){
    const result = new Map()
    hash.set(obj,result) //等级隐射关系，解决循环引用

    // map.forEach((value, key, mapItself) => {参数顺序：值、键、Map本身});
    obj.forEach((value,key)=>{
      result.set(deepClone(key,hash),deepClone(value,hash))//递归键值对
    })
    return result
  }
  // 6.处理Set函数
  if(obj instanceof Set){
    const result = new Set()
    hash.set(obj,result)

    obj.forEach((value,key)=>{
      result.add(deepClone(value,hash))// 对每个值进行深拷贝，然后添加到新Set中
    })
    return result
  }
  // 7.检查循环引用 - 如果已经拷贝过该对象，直接返回存储的拷贝
  if(hash.has(obj)){
    return hash.get(obj)
  }

  // 8.处理普通对象 - 创建保持原型链的新对象
  // Object.create(null)，把null换成了指定的对象，且这个对象有原型链
  const result = Object.create(Object.getPrototypeOf(obj)) 
  // 建立隐射关系 解决循环引用
  hash.set(obj,result)
  // Reflect.ownKeys获取自由属性 如不可枚举和Symbol属性
  const keys = Reflect.ownKeys(obj)
  for(let key of keys){
    result[key] = deepClone(obj[key], hash)
  }
  return result
}
```
::: info 手写深拷贝函数引发的思考

1. `instanceof`是检查实例归属的方法，且其检查依赖于运行时的原型链。但如果代码运行在多个框架或窗口（iframe）中，由于每个环境都有自己全局的执行上下文和内置构造函数，跨环境的对象检查可能会失败。在这种情况下，使用`Array.isArray()`或`Object.prototype.toString.call()`方法更可靠。
2. `Object.create(null)`是创建一个无原型链的纯净对象，在一些底层框架经常使用
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-10_20-59-54.jpg)
3. 关于手写函数的第二个参数为什么要用`hash = new WeakMap()`
WeakMap 的键是弱引用。这意味着，如果原始对象在其他地方已经没有引用了，它会被垃圾回收机制自动回收，同时它在 WeakMap 中的记录也会被自动清除。这避免了深拷贝这个临时性操作可能导致的内存泄漏。
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_18-36-37.jpg)
WeakMap对应的方法：
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_18-45-55.jpg)
4. `Reflect.ownKeys()` 是 ES6 引入的反射 API 的一部分，返回的是对象**所有自有属性的键**（包括字符串键和Symbol键，无论是否可枚举），这确保了深拷贝能够复制对象的所有属性。
5. 关于Set
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-09-11_22-09-59.jpg)
6. 理解`Object.create(Object.getPrototypeOf(obj))`这里不展开写
:::

## 一、数组扁平化

![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-08-27_01-37-30.jpg)

### ES6 的 flat 方法

flat()将以指定的深度递归遍历数组，并将所有元素与遍历的子数组中元素合并到一个新数组中以返回。

**💭flat(Infinity)** 优雅且强大的写法，完全展平一个任意嵌套深度的数组
```js
const arr = [1,[2,[3,[4,5]]],6]
console.log(arr.flat()) //  [1, 2, Array(2), 6]
console.log(arr.flat(Infinity)) // [1,2,3,4,5,6]
```
![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2025-08-27_01-47-44.jpg)

### 使用正则

```js
const arr = [1,[2,[3,[4,5]]],6]
//\[|]\
const res = JSON.stringify(arr).replace(/\[|\]/g,'')
const res2 = JSON.parse('[' + res + ']')
```

### 使用递归

[本博客《算法思想：递归》](/blogs/category1/2025/0601.html#递归思想)

```js
 let array = []  
  const fn = (arr) => {
    for (let i = 0; i < arr.length; i++) {
      if(Array.isArray(arr[i])){
        fn(arr[i])
      }else{
        array.push(arr[i])
      }
    }
  }
  const arr = [1,[2,[3,[4,5]]],6]
  // fn(arr)
  // console.log( array ) //[1,2,3,4,5,6]
```

### 使用reduce

```js
const fn = (arr) => {
  return arr.reduce((pre,cur)=>{
    return pre.concat(Array.isArray(cur)?fn(cur):cur)
  },[])
}
```

### 使用stack思想实现

```js
function flatWithStack(arr) {
  const stack = [...arr].reverse() // 初始栈，逆序压入元素
  const result = []
  while (stack.length > 0) {
    const item = stack.pop()
    if (Array.isArray(item)) {
      stack.push(...item.reverse())// 如果是数组，将其元素逆序压回栈中
    } else {
      result.push(item)// 如果不是数组，加入结果数组
    }
  }
  return result;
}
```